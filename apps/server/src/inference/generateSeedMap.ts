/**
 * Auto-generate industry seed map from occupations
 * This replaces the manual INDUSTRY_SEED_MAP with automated generation
 */

import { OCCUPATIONS } from '@shared/occupations';
import type { SeedMatch } from './industrySeedMap';

/**
 * Generate seed map from occupations with seedMappings
 */
export function generateSeedMap(): Map<string, SeedMatch> {
  const seedMap = new Map<string, SeedMatch>();
  
  for (const occ of OCCUPATIONS) {
    if (!occ.seedMappings) continue;
    
    // Add canonical name (confidence 1.0)
    seedMap.set(occ.displayName, {
      category: occ.seedMappings.category,
      segment: occ.seedMappings.segment,
      niche: occ.seedMappings.niche,
      confidence: 1.0
    });
    
    // Add all synonyms (confidence 0.95)
    for (const syn of occ.synonyms) {
      // Skip very generic synonyms that might cause conflicts
      if (syn.length < 2) continue;
      
      seedMap.set(syn, {
        category: occ.seedMappings.category,
        segment: occ.seedMappings.segment,
        niche: occ.seedMappings.niche,
        confidence: 0.95
      });
    }
    
    // ðŸ†• Add high-value keywords (confidence 0.80)
    for (const keyword of occ.keywords) {
      // Only add meaningful, specific keywords
      if (keyword.length < 2) continue;
      
      // Exclude overly generic terms
      const genericTerms = ['å·¥ç¨‹å¸ˆ', 'ç»ç†', 'å¸ˆ', 'å‘˜', 'äºº', 'å·¥ä½œ', 
                           'engineer', 'manager', 'å¤§åŽ‚', 'äº’è”ç½‘'];
      if (genericTerms.some(term => keyword === term)) continue;
      
      // Avoid conflicts: only add if not exists
      if (!seedMap.has(keyword)) {
        seedMap.set(keyword, {
          category: occ.seedMappings.category,
          segment: occ.seedMappings.segment,
          niche: occ.seedMappings.niche,
          confidence: 0.80
        });
      }
    }
  }
  
  return seedMap;
}

/**
 * Merge auto-generated seed map with manual overrides
 */
export function generateMergedSeedMap(manualOverrides?: Map<string, SeedMatch>): Map<string, SeedMatch> {
  const autoGenerated = generateSeedMap();
  
  if (!manualOverrides) {
    return autoGenerated;
  }
  
  // Manual overrides take precedence
  for (const [key, value] of manualOverrides) {
    autoGenerated.set(key, value);
  }
  
  return autoGenerated;
}

// Export as constant for runtime use
export const GENERATED_SEED_MAP = generateSeedMap();

// Get stats about the generated seed map
export function getSeedMapStats() {
  const map = GENERATED_SEED_MAP;
  const occupationsWithMappings = OCCUPATIONS.filter(o => o.seedMappings).length;
  
  return {
    totalEntries: map.size,
    occupationsWithMappings,
    coverageRatio: occupationsWithMappings / OCCUPATIONS.length,
  };
}
