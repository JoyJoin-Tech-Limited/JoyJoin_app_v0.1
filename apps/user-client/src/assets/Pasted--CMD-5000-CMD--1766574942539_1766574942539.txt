短答案先给你：
不行 ❌，CMD [] 这里“不能也不该”写 5000。
端口 不是 在 CMD 里写的，这正是你现在卡死的根本原因之一。

下面我用最直接、不绕弯的方式给你拆清楚 👇

⸻

一句话结论（很重要）

CloudBase 显示端口 = 0，不是因为你没填 5000，而是因为：

👉 容器启动时根本没成功跑起来 / 没有进程在监听端口
👉 CloudBase 只能看到一个“空壳容器”，就只能显示端口 0

⸻

❌ 为什么不能在 CMD 里“直接写 5000”

你现在看到的是：

CMD []
ENTRYPOINT []

你在想：

能不能在 CMD 里写个 5000，让它知道端口？

这是不成立的原因：

1️⃣ CMD 是“启动命令”，不是“配置项”

CMD 的本质是 告诉 Docker：容器启动后跑什么进程

例如：

CMD ["node", "dist/index.js"]

或者：

CMD ["npm", "run", "start"]

❌ 下面这种 没有任何意义：

CMD ["5000"]

Docker 只会尝试执行一个叫 5000 的程序 → 直接启动失败

⸻

2️⃣ CloudBase 的「服务端口」≠ Docker CMD
	•	CloudBase 的 服务端口设置（5000）
	•	只是告诉 平台如何做端口映射
	•	前提是：容器里真的有进程在 listen 5000

如果容器没启动成功，或者启动了但没监听端口：

👉 CloudBase 内部拿不到端口 → 显示 0

⸻

🔥 你现在真正的问题是什么（我很确定）

结合你之前说的：

“检查发现最初的（改结构之前）Dockerfile 忘记删了”

	•	

版本配置里 CMD / ENTRYPOINT 为空

	•	

版本里端口永远是 0

👉 结论几乎可以 100% 确定：

你现在被 CloudBase 拉起的那个镜像里：

❌ 没有正确的 CMD
❌ 或 CMD 指向了一个不存在的入口
❌ Node 服务根本没跑起来

⸻

✅ 正确做法（一步到位）

✅ 做法 A（强烈推荐）：在 Dockerfile 里写死 CMD

你的 server 镜像 Dockerfile 最后必须是类似这样：

FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist ./dist

ENV NODE_ENV=production
ENV PORT=5000

EXPOSE 5000

CMD ["node", "dist/index.js"]

⚠️ 重点只有 3 个：
	1.	CMD ["node", "dist/index.js"]
	2.	app.listen(process.env.PORT || 5000, '0.0.0.0')
	3.	重新 build + push 镜像

⸻

✅ CloudBase 这边你只需要：
	•	镜像部署
	•	服务端口：5000
	•	CMD / ENTRYPOINT 留空（用镜像自带的）

CloudBase 不会覆盖 Dockerfile 里的 CMD

⸻

❌ 不要做的事情（踩一次就会无限循环）
	•	❌ 在 CloudBase 里手写 CMD
	•	❌ 同时存在多个 Dockerfile 不确定用哪个
	•	❌ 用 Git 仓库部署 + 镜像部署混在一起
	•	❌ 指望 CloudBase “猜”你的端口

⸻

🧠 为什么你会看到「配置页是 5000，但版本页是 0」

这是 CloudBase 的一个非常反直觉但真实的行为：
	•	配置页：你填的期望值（静态）
	•	版本页：运行时探测结果（动态）

👉 容器没成功监听 → 运行时端口 = 0

⸻

下一步我建议你这样做（不多一步）
	1.	确认只保留一个 Dockerfile（server 用的）
	2.	Dockerfile 里 明确写 CMD
	3.	本地 docker run -p 5000:5000 镜像 能访问
	4.	GH Actions push 新镜像
	5.	CloudBase 新建一个服务，用新镜像

⸻

如果你愿意，下一条你可以直接把👇其中一个贴出来，我可以直接“点名哪行是罪魁祸首”：
	•	当前 apps/server/Dockerfile
	•	或 dist/index.js 里 listen 的那几行
	•	或 GH Actions build-api 用的 Dockerfile 路径

你这个问题已经不是“概念不懂”，而是差最后一颗螺丝了，我们可以直接拧上。