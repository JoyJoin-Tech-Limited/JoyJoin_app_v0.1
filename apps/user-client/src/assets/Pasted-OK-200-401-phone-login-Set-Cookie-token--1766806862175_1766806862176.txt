OK，这下就很明确了：登录 200 之后立刻 401 的根因几乎确定——

你的 phone-login 响应 没有 Set-Cookie，也没有返回 token。
所以浏览器根本没有“登录凭证”可以带去 /api/auth/user，那它 401 是必然的。

你现在看到的 response headers 里确实没有 Set-Cookie（而且你贴的 JSON body 也没有 accessToken），这就是关键证据。

为什么会出现“登录成功但没登录态”

很多项目会这样写登录接口：

校验手机号/验证码 ✅

返回用户信息 ✅

但忘了：真正建立登录态（写 session / 发 cookie / 发 token）❌

于是前端立刻去 /auth/user（需要鉴权），后端就说你没登录 → 401。

你要做的选择：用哪种登录态（两条路，选一条就能修）
路线 A：Cookie Session（推荐 admin portal）

目标：POST /phone-login 返回时必须下发 Set-Cookie，之后 /auth/user 自动带 cookie。

路线 B：JWT Token

目标：POST /phone-login 返回 accessToken，前端存起来，之后 /auth/user 带 Authorization: Bearer <token>。

你现在显然两边都没做，所以才会这样。

✅ 快速修复方案（我按你是 Express 给你落地写法）
方案 A：用 express-session（cookie session）

1）安装

npm i express-session


2）在 app 里加 session（在所有路由之前）

import session from "express-session";

app.set("trust proxy", 1); // 你前面有 Caddy/nginx，非常关键

app.use(session({
  name: "joyjoin_admin_sid",
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    secure: true,      // 你是 https
    sameSite: "lax",   // admin 同站点够用
    path: "/",
    maxAge: 7 * 24 * 60 * 60 * 1000
  }
}));


3）登录成功时写 session

// phone-login 成功后
req.session.userId = user.id;
return res.json({ message: "Login successful", ...safeUser });


4）/auth/user 从 session 读

app.get("/api/auth/user", async (req, res) => {
  if (!req.session?.userId) return res.status(401).json({ message: "Unauthorized" });
  const user = await db.user.findById(req.session.userId);
  return res.json(user);
});


✅ 这样一来，你再看 Network：phone-login 的 response headers 会多出 Set-Cookie，然后 /auth/user request headers 会自动带 Cookie:，401 就没了。

生产环境强烈建议 session store 用 Redis（否则重启丢 session），但你现在先把登录链路打通。

方案 B：JWT（token）

1）安装

npm i jsonwebtoken


2）登录成功返回 token

import jwt from "jsonwebtoken";

const token = jwt.sign(
  { userId: user.id, isAdmin: user.isAdmin },
  process.env.JWT_SECRET,
  { expiresIn: "7d" }
);

return res.json({ message: "Login successful", token, user: safeUser });


3）前端对后续请求带 Authorization

axios 拦截器（示例）：

axios.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});


4）/auth/user 校验 token

function auth(req, res, next) {
  const h = req.headers.authorization || "";
  const token = h.startsWith("Bearer ") ? h.slice(7) : null;
  if (!token) return res.status(401).json({ message: "Unauthorized" });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch {
    return res.status(401).json({ message: "Unauthorized" });
  }
}

app.get("/api/auth/user", auth, async (req, res) => {
  const user = await db.user.findById(req.user.userId);
  res.json(user);
});

你现在应该怎么选？

Admin portal（浏览器 Web 管理端）通常我更建议 Cookie session + HttpOnly（更安全、简单）

Mobile / 小程序 / App 更常用 JWT

但你们也可以：

admin 用 cookie session

user app 用 JWT
（两套 auth 分开）

你给我两个信息，我能直接告诉你“你当前项目更像哪套”，并给你精准改动点

你后端目前有没有用 passport / express-session / jsonwebtoken？

/api/auth/user 的鉴权逻辑现在是什么（从 cookie 读还是从 header 读）？把那段中间件/路由代码贴出来（打码 secret）。

另外一个小坑：你现在返回了完整 user 对象（包含大量敏感字段）

就算登录打通了，也建议：

返回 “admin 需要的字段子集”

别把 phone/email/偏好等全回给前端管理端，避免泄露面扩大