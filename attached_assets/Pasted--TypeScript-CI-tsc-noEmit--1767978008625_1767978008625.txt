你把 TypeScript 的类型检查真正跑起来了，它开始把以前一直“潜伏着”的问题全都报出来——属于 一次性清债。程序能跑只是因为运行时不看类型；CI 的 tsc --noEmit 是在把类型当成质量门槛。

而且你现在新出现的几类错误，已经很明确告诉你：routes.ts 里你动过的类型改法把推断链条弄断了，于是：

原来能推断出来的现在推不出来 → TS7006 暴增（回调参数全变 any）

原来“可能是 undefined”的地方被严格指出 → TS2345/TS2769

session 上你自定义字段没做类型扩展 → TS2339

我按错误类型给你一套“最快过关”的修法（不是讲概念，是给你直接能改的模式）。

1) TS7006：Parameter 'u/r/m/p' implicitly has any

这类通常是 .map(u => ...) / .filter(r => ...) 的上游数组变成了 any[] 或 unknown[]。

✅ 最快的修法：给数组/查询结果补类型（别给每个 u 都写 any）

比如你现在很多是 r，看起来像 DB 查询返回 rows：

坏：

const rows = await db.select().from(table); // rows 类型没推断出来/退化
rows.map(r => r.id); // r => any


好：

const rows = await db.select().from(table); // 如果 Drizzle，通常能推断
rows.map((r) => r.id); // r 自动有类型


如果推断还是不行（经常出现在你把查询封装成函数但没写返回类型）：

type UserRow = { id: string; ... };
const rows: UserRow[] = await getUsers();
rows.map(r => r.id);


重点：别在 map 里写 (r: any)，要在 rows 上把类型定住，一处改动能消灭一串 TS7006。

2) TS2345：string | undefined 不能当 string 用

你在 routes.ts 512/527/561 这种错误，典型来源：

req.query.xxx（天生 string | undefined）

req.headers.xxx（可能 undefined）

req.params.xxx（如果没声明 params 类型也会变宽）

session/userId 没保证存在

✅ 正确修法：在进入逻辑前做 “guard + early return”

比如：

const userId = req.session.userId;
if (!userId) return res.status(401).json({ message: "Unauthorized" });

// 下面 userId 就是 string 了
await doSomething(userId);


或者 query：

const phone = req.query.phone;
if (typeof phone !== "string") return res.status(400).json({ message: "phone required" });


这不只是为了过 tsc，也是在修真实潜在 bug：你线上确实可能拿到 undefined。

3) TS2339：req.session.isAdmin 不存在

你给 session 塞了 isAdmin，但 express-session 的默认类型不知道这个字段。

✅ 正确修法：做 SessionData 的 module augmentation（一次改全项目都好）

在 apps/server/src/types/express-session.d.ts（或任意被 tsconfig include 的 .d.ts）加：

import "express-session";

declare module "express-session" {
  interface SessionData {
    userId?: string;
    isAdmin?: boolean;
  }
}


然后你 routes 里：

req.session.isAdmin = true;


就不会报错了。

4) TS2769（Drizzle 的 eq / where 匹配失败）：你把 undefined 传进 SQL 条件了

你这里的报错很典型：

eq(event_attendance.user_id, userId) 但 userId 是 string | undefined

Drizzle 的 eq 不接受 undefined，所以 overload 全崩

✅ 正确修法：同样先 guard
const userId = req.session.userId;
if (!userId) return res.status(401).json({ message: "Unauthorized" });

const rows = await db.select().from(eventAttendance).where(eq(eventAttendance.userId, userId));


不要用 userId! 强行断言当 string（短期能过编译，但线上真 undefined 就炸）。

为什么你“改了之后”错误更多？

因为你可能做了两件事之一：

把某些 typed 的东西改成了 any/unknown（比如给 req/res 写了不正确的类型，导致后面推断断）

把隐式问题暴露出来（以前没跑 tsc 或没 strict）

比如你说你“显式 typed Request objects”，如果你写成了类似：

(req: Request, res: Response) => { ... }


但没有给 Request 的泛型参数（params/query/body）
那 req.query.xxx 反而更容易是 string | undefined，而且你的逻辑里可能之前一直没处理 undefined。

最快把 CI 拉绿的执行顺序（建议你照这个顺序改）

先修 Session 类型扩展（TS2339 一刀切）

把 routes.ts 里所有 string|undefined 先 guard 掉（TS2345/TS2769 会大幅减少）

再修 poolMatchingService.ts 的 u/r（TS7006）

优先从上游返回类型/数组类型下手

最后再收尾那些 .map(p => ...) 的隐式 any